import { ISendMessageUseCase, SendMessageInput } from '../interfaces/send-message.usecase.interface';
import { IChatRepository } from '../../../repositories/chat.repository.interface';
import { IMessageRepository } from '../../../repositories/message.repository.interface';
import { ChatId } from '../../../../domain/value-object/ChatId';
import { UserId } from '../../../../domain/value-object/UserId';
import { MessageContent } from '../../../../domain/value-object/MessageContent';
import { Message } from '../../../../domain/entities/Message';
import { MessageId } from '../../../../domain/value-object/MessageId';
import { Timestamp } from '../../../../domain/value-object/Timestamp';
import { MessageResponseDTO } from '@/domain/dtos/chat.dto';
import { Chat } from '../../../../domain/entities/Chat';
import { CreateNotificationsForUsersUseCase } from '../../notification/implementations/create-notifications-for-users.usecase';
import { NotificationBatchingService } from '../../../services/notification/notification-batching.service';

export class SendMessageUseCase implements ISendMessageUseCase {
  private notificationBatchingService?: NotificationBatchingService;

  constructor(
    private readonly chatRepository: IChatRepository,
    private readonly messageRepository: IMessageRepository,
    private readonly createNotificationsForUsersUseCase?: CreateNotificationsForUsersUseCase
  ) {
    if (createNotificationsForUsersUseCase) {
      this.notificationBatchingService = new NotificationBatchingService(createNotificationsForUsersUseCase);
    }
  }

  async execute(input: SendMessageInput): Promise<MessageResponseDTO> {
    let chatId: ChatId;
    if (input.chatId) {
      chatId = new ChatId(input.chatId);
    } else if (input.userId) {
      const senderId = new UserId(input.senderId);
      const recipientId = new UserId(input.userId);
      let chat = await this.chatRepository.getChatBetweenUsers(senderId, recipientId);
      if (!chat) {
        chat = await this.chatRepository.create(
          new Chat(
            undefined as any, // id will be generated by Prisma
            senderId,
            recipientId,
            new Timestamp(new Date()),
            new Timestamp(new Date()),
            []
          )
        );
        if (!chat) {
          throw new Error('Failed to create chat');
        }
      }
      chatId = chat.id;
    } else {
      throw new Error('Either chatId or userId must be provided');
    }
    const message = new Message(
      new MessageId(Math.random().toString(36).substring(2, 15)),
      chatId,
      new UserId(input.senderId),
      new MessageContent(input.content),
      new Timestamp(new Date())
    );
    try {
      await this.messageRepository.create(message);
    } catch (err) {
      throw err;
    }
    if (chatId && (input.chatId || input.userId)) {
      let chat = input.chatId ? await this.chatRepository.findById(chatId) : null;
      if (!chat) {
        chat = await this.chatRepository.getChatBetweenUsers(new UserId(input.senderId), new UserId(input.userId!));
      }
      if (chat) {
        const updatedChat = new Chat(
          chat.id,
          chat.user1Id,
          chat.user2Id,
          chat.createdAt,
          new Timestamp(new Date()),
          chat.messages
        );
        await this.chatRepository.save(updatedChat);
      }
    }
    let enrichedMessage: any = null;
    try {
      enrichedMessage = await this.messageRepository.findByIdWithUserData(message.id);
    } catch (err) {
      // Optionally handle error, but no log needed
    }
    if (!enrichedMessage) {
      return {
        id: message.id.value,
        chatId: message.chatId.value,
        senderId: message.senderId.value,
        receiverId: input.userId || '',
        content: message.content.value,
        timestamp: message.createdAt.value ? new Date(message.createdAt.value).toISOString() : '',
      };
    }
    const chat = await this.chatRepository.findById(chatId);
    if (!chat) {
      return {
        id: enrichedMessage.id,
        chatId: enrichedMessage.chatId,
        senderId: enrichedMessage.senderId,
        receiverId: input.userId || '',
        content: enrichedMessage.content,
        timestamp: enrichedMessage.createdAt ? new Date(enrichedMessage.createdAt).toISOString() : '',
      };
    }
    const receiverId = chat.user1Id.value === enrichedMessage.senderId ? chat.user2Id.value : chat.user1Id.value;
    
    // Use batched notifications instead of individual notifications
    if (this.notificationBatchingService) {
      try {
        await this.notificationBatchingService.addMessageToBatch(
          receiverId,
          enrichedMessage.senderId,
          enrichedMessage.senderName || 'Someone',
          chatId.value,
          input.content
        );
      } catch (error) {
        // Don't fail the message sending if notification fails
        console.error('Failed to add message to notification batch:', error);
      }
    }
    
    return {
      id: enrichedMessage.id,
      chatId: enrichedMessage.chatId,
      senderId: enrichedMessage.senderId,
      receiverId,
      content: enrichedMessage.content,
      timestamp: enrichedMessage.createdAt ? new Date(enrichedMessage.createdAt).toISOString() : '',
    };
  }
} 