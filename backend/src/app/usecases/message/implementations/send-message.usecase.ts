import { ISendMessageUseCase, SendMessageInput } from '../interfaces/send-message.usecase.interface';
import { IChatRepository } from '../../../repositories/chat.repository.interface';
import { IMessageRepository } from '../../../repositories/message.repository.interface';
import { ChatId } from '../../../../domain/value-object/ChatId';
import { UserId } from '../../../../domain/value-object/UserId';
import { MessageContent } from '../../../../domain/value-object/MessageContent';
import { Message } from '../../../../domain/entities/Message';
import { MessageId } from '../../../../domain/value-object/MessageId';
import { Timestamp } from '../../../../domain/value-object/Timestamp';
import { MessageResponseDTO } from '@/domain/dtos/chat.dto';
import { randomUUID } from 'crypto';
import { Chat } from '../../../../domain/entities/Chat';

export class SendMessageUseCase implements ISendMessageUseCase {
  constructor(
    private readonly chatRepository: IChatRepository,
    private readonly messageRepository: IMessageRepository
  ) {}

  async execute(input: SendMessageInput): Promise<MessageResponseDTO> {
    console.log('[SendMessageUseCase] execute called with input:', input);
    let chatId: ChatId;
    if (input.chatId) {
      chatId = new ChatId(input.chatId);
    } else if (input.userId) {
      const senderId = new UserId(input.senderId);
      const recipientId = new UserId(input.userId);
      console.log('[SendMessageUseCase] No chatId provided, checking for existing chat between', senderId.value, 'and', recipientId.value);
      let chat = await this.chatRepository.getChatBetweenUsers(senderId, recipientId);
      if (!chat) {
        console.log('[SendMessageUseCase] No chat found, creating new chat...');
        chat = await this.chatRepository.create(
          new Chat(
            undefined as any, // id will be generated by Prisma
            senderId,
            recipientId,
            new Timestamp(new Date()),
            new Timestamp(new Date()),
            []
          )
        );
        if (!chat) {
          console.error('[SendMessageUseCase] Failed to create chat');
          throw new Error('Failed to create chat');
        }
        console.log('[SendMessageUseCase] Chat created:', chat.id.value);
      } else {
        console.log('[SendMessageUseCase] Found existing chat:', chat.id.value);
      }
      chatId = chat.id;
    } else {
      throw new Error('Either chatId or userId must be provided');
    }
    console.log('[SendMessageUseCase] Creating message for chatId:', chatId.value);
    const message = new Message(
      new MessageId(Math.random().toString(36).substring(2, 15)),
      chatId,
      new UserId(input.senderId),
      new MessageContent(input.content),
      new Timestamp(new Date())
    );
    console.log('[SendMessageUseCase] Message object before storing:', message);
    try {
      await this.messageRepository.create(message);
      console.log('[SendMessageUseCase] Message created in DB:', message.id.value);
    } catch (err) {
      console.error('[SendMessageUseCase] Error creating message:', err);
      throw err;
    }
    if (chatId && (input.chatId || input.userId)) {
      let chat = input.chatId ? await this.chatRepository.findById(chatId) : null;
      if (!chat) {
        chat = await this.chatRepository.getChatBetweenUsers(new UserId(input.senderId), new UserId(input.userId!));
      }
      if (chat) {
        await this.chatRepository.save(chat);
      }
    }
    let enrichedMessage: any = null;
    try {
      enrichedMessage = await this.messageRepository.findByIdWithUserData(message.id);
      console.log('[SendMessageUseCase] Enriched message result:', enrichedMessage);
    } catch (err) {
      console.error('[SendMessageUseCase] Error fetching enriched message:', err);
    }
    if (!enrichedMessage) {
      console.warn('[SendMessageUseCase] No enriched message found for id:', message.id.value);
      return {
        id: message.id.value,
        chatId: message.chatId.value,
        senderId: message.senderId.value,
        receiverId: input.userId || '',
        content: message.content.value,
        timestamp: message.createdAt.value ? new Date(message.createdAt.value).toISOString() : '',
      };
    }
    const chat = await this.chatRepository.findById(chatId);
    if (!chat) {
      return {
        id: enrichedMessage.id,
        chatId: enrichedMessage.chatId,
        senderId: enrichedMessage.senderId,
        receiverId: input.userId || '',
        content: enrichedMessage.content,
        timestamp: enrichedMessage.createdAt ? new Date(enrichedMessage.createdAt).toISOString() : '',
      };
    }
    const receiverId = chat.user1Id.value === enrichedMessage.senderId ? chat.user2Id.value : chat.user1Id.value;
    return {
      id: enrichedMessage.id,
      chatId: enrichedMessage.chatId,
      senderId: enrichedMessage.senderId,
      receiverId,
      content: enrichedMessage.content,
      timestamp: enrichedMessage.createdAt ? new Date(enrichedMessage.createdAt).toISOString() : '',
    };
  }
} 